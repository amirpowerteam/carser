<!doctype html>
<html lang="fa" dir="rtl">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="description" content="Ù¾Ø§Ø¯Ú©Ø³Øª Ú©ØªØ§Ø¨â€ŒØ¬ÛŒØ¨ÛŒ â€” Ø®Ù„Ø§ØµÙ‡ Ú©ØªØ§Ø¨â€ŒÙ‡Ø§ Ùˆ Ø§Ù¾ÛŒØ²ÙˆØ¯Ù‡Ø§ÛŒ ØµÙˆØªÛŒ">
    <meta property="og:title" content="Ù¾Ø§Ø¯Ú©Ø³Øª Ú©ØªØ§Ø¨ Ø¬ÛŒØ¨ÛŒ">
    <meta property="og:description" content="Ø®Ù„Ø§ØµÙ‡ Ú©ØªØ§Ø¨â€ŒÙ‡Ø§ Ø¨Ù‡ Ø´Ú©Ù„ ØµÙˆØªÛŒØ› Ø´Ù†ÛŒØ¯Ù† Ùˆ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ø³Ø±ÛŒØ¹">
    <meta property="og:image" content="/hero.svg">
    <meta property="og:type" content="website">
    <title>Ú©ØªØ§Ø¨ Ø¬ÛŒØ¨ÛŒ - Ù†Ø³Ø®Ù‡ Ù†Ù…ÙˆÙ†Ù‡</title>
    <link rel="stylesheet" href="/styles.css">
    <link rel="icon" href="/logo.svg" type="image/svg+xml">
    <style>
      /* Sticky footer audio player */
      .sticky-player{position:fixed;left:16px;right:16px;bottom:16px;background:rgba(10,10,10,0.92);color:#fff;border-radius:12px;padding:10px 14px;display:flex;align-items:center;gap:12px;z-index:9999}
      .sticky-player .btn{background:transparent;border:0;color:inherit;font-size:18px;cursor:pointer}
      .sticky-player .label{min-width:120px}
      .search-modal{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:flex-start;justify-content:center;padding-top:80px;z-index:10000}
      .search-modal .panel{background:#0f0f11;color:#fff;padding:18px;border-radius:8px;width:min(880px,96%);max-height:70vh;overflow:auto}
      .search-results .item{padding:8px 6px;border-bottom:1px solid rgba(255,255,255,0.04);cursor:pointer}
    </style>
  </head>
  <body class="rtl">
    <div class="container">
      <header class="navbar">
        <div class="platform-icons" aria-hidden="true">
          <a href="#" title="Spotify">ğŸ§</a>
          <a href="#" title="Apple">ï£¿</a>
          <a href="#" title="YouTube">â–¶ï¸</a>
          <a href="#" title="Telegram">âœˆï¸</a>
        </div>
        
        <div class="nav-center">
          <nav class="nav-links">
            <a class="tab" href="/">Ø®Ø§Ù†Ù‡</a>
            <a class="tab" href="/readables">Ø®ÙˆØ§Ù†Ø¯Ù†ÛŒâ€ŒÙ‡Ø§</a>
            <a class="tab" href="/episodes">Ø§Ù¾ÛŒØ²ÙˆØ¯Ù‡Ø§</a>
            <a class="tab" href="/sponsor.html">Ø§Ø³Ù¾Ø§Ù†Ø³Ø± Ø´ÙˆÛŒØ¯</a>
            <a class="tab" href="/contact.html">ØªÙ…Ø§Ø³ Ø¨Ø§ Ù…Ø§</a>
            <a class="tab" href="/sponsor.html">Ø­Ù…Ø§ÛŒØª Ù…Ø§Ù„ÛŒ</a>
          </nav>
          <div class="search-wrap">
            <span style="position:relative;display:inline-flex;align-items:center;gap:8px">
              <button id="searchIcon" class="theme-toggle" title="Ø¬Ø³ØªØ¬Ùˆ" style="padding:8px;border-radius:8px;margin-left:8px">ğŸ”</button>
              <input id="siteSearch" type="search" class="search" placeholder="Ø¬Ø³ØªØ¬Ùˆ...">
            </span>
          </div>
        </div>
        <div class="logo">
          <img src="/logo.svg" alt="Ú©ØªØ§Ø¨â€ŒØ¬ÛŒØ¨ÛŒ" class="site-logo">
        </div>
        <button id="themeToggle" class="theme-toggle" title="ØªØºÛŒÛŒØ± Ø­Ø§Ù„Øª Ø±ÙˆØ²/Ø´Ø¨">ğŸŒ™</button>
      </header>

      <main>
        <section id="siteNote" style="background:#fff3bf;color:#000;padding:10px;border-radius:8px;margin:12px 0;direction:rtl;display:flex;align-items:center;justify-content:space-between;gap:12px">
          <div>
            <strong>ÛŒØ§Ø¯Ø¯Ø§Ø´Øª ØªÛŒÙ…:</strong>
            <span id="siteNoteText">Ø§ÛŒÙ† ÛŒØ§Ø¯Ø¯Ø§Ø´Øª Ø¨Ø±Ø§ÛŒ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ø¨Ù‚ÛŒÙ‡Ù” Ú©Ø§Ø±Ù‡Ø§ Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØª â€” Ù„Ø·ÙØ§Ù‹ Ø§Ù…Ø±ÙˆØ² Ø§Ø¯Ø§Ù…Ù‡Ù” Ú©Ø§Ø±Ù‡Ø§ Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡ÛŒØ¯.</span>
          </div>
          <div>
            <button id="dismissNote" style="background:#222;color:#fff;border:0;padding:6px 10px;border-radius:6px;cursor:pointer">Ø¨Ø³ØªÙ†</button>
          </div>
        </section>
        <section class="hero">
          <div class="hero-wrapper">
            <div class="hero-cover" id="heroCover">
              <img id="heroImg" alt="hero cover" />
              <div class="hero-content">
                <h1 id="heroTitle">Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù¾ÛŒØ²ÙˆØ¯ Ø¬Ø¯ÛŒØ¯</h1>
                <p class="summary" id="heroSummary">Ø®Ù„Ø§ØµÙ‡ Ú©ÙˆØªØ§Ù‡ Ø§Ù¾ÛŒØ²ÙˆØ¯Ù Ø¬Ø¯ÛŒØ¯ Ø§ÛŒÙ†Ø¬Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.</p>
                <div class="hero-controls">
                  <button class="play-pill" id="heroPlay"><span class="icon">â–¶</span><span class="label">Play</span></button>
                  <span class="meta" id="heroMeta">â€”</span>
                </div>
              </div>
            </div>
          </div>
        </section>

        <section class="stats" aria-label="Ø¢Ù…Ø§Ø± Ø³Ø§ÛŒØª">
          <div id="statEpisodes">0 Ø§Ù¾ÛŒØ²ÙˆØ¯</div>
          <div id="statListeners">0 Ø´Ù†ÙˆÙ†Ø¯Ù‡</div>
          <div id="statArchive">Ø¢Ø±Ø´ÛŒÙˆ Ú©ØªØ§Ø¨ÛŒ</div>
        </section>

        <section class="filters" style="margin-top:18px">
          <div id="categoryChips" style="display:flex;gap:8px;flex-wrap:wrap"></div>
        </section>

        <section class="grid" id="episodeGrid" aria-label="ÙÙ‡Ø±Ø³Øª Ø§Ù¾ÛŒØ²ÙˆØ¯Ù‡Ø§">
          <!-- episode cards will be injected here -->
        </section>

        <section class="uploads" style="margin-top:18px">
          <h3>Ø¢Ø®Ø±ÛŒÙ† Ø¢Ù¾Ù„ÙˆØ¯Ù‡Ø§</h3>
          <div id="uploadsList"></div>
        </section>
      </main>

      <footer class="sponsor">
        <div>Ø­Ù…Ø§ÛŒØª Ø§Ø² Ù¾Ø§Ø¯Ú©Ø³Øª â€” Ù‡Ù…Ø±Ø§Ù‡ Ø¨Ø§ Ù„ÛŒÙ†Ú© Ù¾Ø±Ø¯Ø§Ø®Øª</div>
        <div style="margin-top:8px">
          <a class="cta" href="/sponsor.html">Ø­Ù…Ø§ÛŒØª Ú©Ù†</a>
        </div>
      </footer>

      
    </div>
    <script>
      (function(){
        try{
          const note = document.getElementById('siteNote');
          const btn = document.getElementById('dismissNote');
          if(!note || !btn) return;
          if(localStorage.getItem('kj_site_note_hidden')==='1'){ note.style.display='none'; return; }
          btn.addEventListener('click', ()=>{ note.style.display='none'; localStorage.setItem('kj_site_note_hidden','1'); });
        }catch(e){}
      })();
    </script>

    <script src="/js/audio.js"></script>
    <script src="/js/pjax.js"></script>
    <script>
      // small nav active helper
      (function(){
        const links = document.querySelectorAll('.nav-links a');
        links.forEach(a=>{ if(a.getAttribute('href')===location.pathname) a.classList.add('active'); });
      })();

      const apPlay = document.getElementById('ap-play');
      // shared Audio controller to avoid DOM audio collisions
      const audio = (function(){
        if(window.sharedPlayer) return window.sharedPlayer;
        const p = new Audio();
        // preload full resource so the browser can buffer and start playback faster
        p.preload = 'auto';
        // allow cross-origin requests when streaming from /media
        try{ p.crossOrigin = 'anonymous'; }catch(e){}
        window.sharedPlayer = p;
        window.sharedPlayerState = window.sharedPlayerState || { currentPlayBtn: null };
        return p;
      })();
      const sharedState = window.sharedPlayerState;
      // debug: attach listeners to observe playback events and readyState
      try{
        ['loadstart','progress','canplay','canplaythrough','playing','waiting','stalled','error'].forEach(ev=>{
          audio.addEventListener(ev, ()=>{
            try{ console.debug('audio.event', ev, { paused: audio.paused, readyState: audio.readyState, currentTime: audio.currentTime }); }catch(e){}
          });
        });
      }catch(e){}
      function updateApIcon(playing){
        try{
          const ic = apPlay && apPlay.querySelector('.icon');
          if(ic) ic.textContent = playing ? 'â¸' : 'â–¶';
          if(apPlay) { if(playing) apPlay.classList.add('active'); else apPlay.classList.remove('active'); }
        }catch(e){}
      }
      function setButtonPlaying(btn, playing){
        try{
          if(!btn) return;
          const ic = btn.querySelector && btn.querySelector('.icon');
          if(ic) ic.textContent = playing ? 'â¸' : 'â–¶';
          if(playing) btn.classList.add('active'); else btn.classList.remove('active');
        }catch(e){}
      }
      function setPlayingSource(src, btn){
        if(!src) return;
        // Use KJAudio API when available to ensure singleton playback
        const kj = window.KJAudio;
        const perform = async ()=>{
          try{
            // attempt to set source via KJAudio which performs HEAD check
            if(kj){
              const ok = await kj.setSource(src);
              if(!ok){
                console.warn('KJAudio setSource failed for', src);
                if(btn){ btn.disabled = false; const ic = btn.querySelector('.icon'); if(ic) ic.textContent = 'â–¶'; }
                updateApIcon(false);
                return;
              }
              // feedback while buffering
              if(btn){ btn.disabled = true; const ic = btn.querySelector('.icon'); if(ic) ic.textContent = 'â³'; }
              const played = await kj.play().catch(()=>false);
              if(played){ document.querySelectorAll('.play-pill').forEach(p=>setButtonPlaying(p, false)); if(btn) setButtonPlaying(btn, true); updateApIcon(true); sharedState.currentPlayBtn = btn || null; if(btn) btn.disabled = false; }
              else { if(btn){ btn.disabled = false; const ic = btn.querySelector('.icon'); if(ic) ic.textContent = 'â–¶'; } updateApIcon(false); }
              return;
            }
            // fallback: direct audio handling
            audio.src = src;
            try{ audio.load(); }catch(e){}
            audio.play().catch(()=>{});
          }catch(e){ console.error('setPlayingSource failed', e); }
        };
        perform();
      }

      if(apPlay){
        apPlay.addEventListener('click', () => {
          try{
            const kj = window.KJAudio;
            if(kj){
              const st = kj.getState();
              if(!st.src) return;
              if(st.paused){ kj.play().then(()=>{ updateApIcon(true); if(sharedState.currentPlayBtn) setButtonPlaying(sharedState.currentPlayBtn, true); }).catch(e=>console.warn('KJAudio play failed', e)); }
              else { try{ kj.pause(); }catch(e){} updateApIcon(false); document.querySelectorAll('.play-pill').forEach(p=>setButtonPlaying(p, false)); }
            } else {
              if (!audio.src) return;
              if (audio.paused) {
                audio.play().then(()=>{ updateApIcon(true); if(sharedState.currentPlayBtn) setButtonPlaying(sharedState.currentPlayBtn, true); }).catch(e=>console.warn('play failed', e));
              } else {
                try{ audio.pause(); }catch(err){ console.error('audio.pause failed', err); }
                updateApIcon(false); document.querySelectorAll('.play-pill').forEach(p=>setButtonPlaying(p, false));
              }
            }
          }catch(e){ console.error(e); }
        });
      }
      // keep icon in sync with actual audio events (covers external changes)
      audio.addEventListener('play', ()=>{ updateApIcon(true); });
      audio.addEventListener('pause', ()=>{ updateApIcon(false); document.querySelectorAll('.play-pill').forEach(p=>setButtonPlaying(p, false)); });

      // --- Sticky player controls & persistence ---
      // Access sticky player elements lazily to avoid errors when the script
      // runs before the DOM nodes exist (inline script appears before markup).
      function showStickyFor(src,label){
        const stickyEl = document.getElementById('stickyPlayer');
        const spLabelEl = document.getElementById('spLabel');
        const spSpeedEl = document.getElementById('spSpeed');
        if(!stickyEl) return;
        if(!src){ stickyEl.style.display='none'; return }
        stickyEl.style.display='flex';
        if(spLabelEl) spLabelEl.textContent = label || src.split('/').pop();
        try{ const cur = localStorage.getItem('kj_player_speed') || '1.25'; if(spSpeedEl) spSpeedEl.value = cur; audio.playbackRate = Number(cur); }catch(e){}
      }

      const spPlayEl = document.getElementById('spPlay');
      const spBackEl = document.getElementById('spBack');
      const spFwdEl = document.getElementById('spFwd');
      const spSpeedEl = document.getElementById('spSpeed');

      if(spPlayEl) spPlayEl.addEventListener('click', ()=>{
        try{
          const kj = window.KJAudio;
          if(kj){ const st = kj.getState(); if(st.paused) kj.play().catch(()=>{}); else kj.pause(); }
          else { if(audio.paused) audio.play().catch(()=>{}); else audio.pause(); }
        }catch(e){}
      });
      if(spBackEl) spBackEl.addEventListener('click', ()=>{ try{ const kj = window.KJAudio; if(kj) kj.seek(Math.max(0, (kj.getState().time||0) - 15)); else audio.currentTime = Math.max(0, audio.currentTime - 15); }catch(e){} });
      if(spFwdEl) spFwdEl.addEventListener('click', ()=>{ try{ const kj = window.KJAudio; const dur = kj ? (kj.getState().duration||0) : (audio.duration||0); const cur = kj ? (kj.getState().time||0) : audio.currentTime; if(kj) kj.seek(Math.min(dur, cur + 15)); else audio.currentTime = Math.min(dur, audio.currentTime + 15); }catch(e){} });
      if(spSpeedEl) spSpeedEl.addEventListener('change', ()=>{ try{ const kj = window.KJAudio; if(kj) kj.setRate(Number(spSpeedEl.value)); else audio.playbackRate = Number(spSpeedEl.value); localStorage.setItem('kj_player_speed', spSpeedEl.value); }catch(e){} });

      // Persist player state periodically
      setInterval(()=>{
        try{
          if(!audio.src) return;
          const state = { src: audio.src, time: Math.floor(audio.currentTime), paused: audio.paused, speed: audio.playbackRate };
          localStorage.setItem('kj_player_state', JSON.stringify(state));
        }catch(e){}
      }, 1000);

      // Restore if present
      try{
        const saved = localStorage.getItem('kj_player_state');
        if(saved){ const s = JSON.parse(saved); if(s && s.src){ audio.src = s.src; audio.currentTime = s.time || 0; audio.playbackRate = s.speed || 1; showStickyFor(s.src, 'Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø®Ø´'); if(!s.paused) audio.play().catch(()=>{}); } }
      }catch(e){}

      // reflect play/pause in sticky button
      audio.addEventListener('play', ()=>{ if(spPlay) spPlay.textContent = 'â¸'; showStickyFor(audio.src); });
      audio.addEventListener('pause', ()=>{ if(spPlay) spPlay.textContent = 'â–¶'; });

      // Update setPlayingSource to reveal sticky player when starting
      const _oldSetPlayingSource = setPlayingSource.bind(window);
      window.setPlayingSource = function(src, btn){ _oldSetPlayingSource(src, btn); showStickyFor(src); };

      // hero elements
      const heroCover = document.getElementById('heroCover');
      const heroImg = document.getElementById('heroImg');
      if(heroImg){
        // if image fails to load, hide it and fall back to neutral background (no inner SVG frame)
        heroImg.onerror = ()=>{ try{ heroImg.style.display='none'; heroImg.src=''; heroCover.style.backgroundImage = ''; heroCover.style.backgroundColor = 'var(--muted-bg)'; }catch(e){} };
      }
      const heroTitle = document.getElementById('heroTitle');
      const heroSummary = document.getElementById('heroSummary');
      const heroMeta = document.getElementById('heroMeta');
      const heroPlay = document.getElementById('heroPlay');

      const statEpisodes = document.getElementById('statEpisodes');
      const statListeners = document.getElementById('statListeners');

      const categoryChips = document.getElementById('categoryChips');
      const episodeGrid = document.getElementById('episodeGrid');

      const uploadsList = document.getElementById('uploadsList');

      let allUploads = [];
      // if user manually selected a hero item (by clicking a card), lock
      // automatic updates for a short period so polling won't override it
      let heroUserLocked = false;
      let heroLockTimer = null;

      async function fetchUploads(){
        try{
          // fetch with timeout to avoid hanging the UI
          const controller = new AbortController();
          const timeout = setTimeout(()=> controller.abort(), 8000);
          const res = await fetch('/api/uploads', { signal: controller.signal });
          clearTimeout(timeout);
          if(!res.ok) throw new Error('server returned ' + res.status);
          allUploads = await res.json();
          renderUploads(allUploads);
          renderEpisodeGrid(allUploads);
          populateHero(allUploads);
          renderStats(allUploads);
          renderCategories(allUploads);
        }catch(e){
          console.error('fetchUploads failed', e);
          allUploads = [];
          try{ renderUploads([]); renderEpisodeGrid([]); renderStats([]); }catch(err){}
          // set a safe placeholder hero so page isn't empty
          try{ setHeroItem({ title: 'Ú©ØªØ§Ø¨â€ŒØ¬ÛŒØ¨ÛŒ', description: 'Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ Ø³Ø±ÙˆØ± Ø¨Ø±Ù‚Ø±Ø§Ø± Ù†Ø´Ø¯', mime: '' }); }catch(err){}
          const uploadsList = document.getElementById('uploadsList');
          if(uploadsList) uploadsList.textContent = 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø²Ø§Ø±ÛŒ Ø§Ù¾ÛŒØ²ÙˆØ¯Ù‡Ø§ â€” Ù„Ø·ÙØ§Ù‹ Ø³Ø±ÙˆØ± Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.';
        }
      }

      function renderUploads(items){
        uploadsList.innerHTML = '';
        if(!items || items.length===0){ uploadsList.textContent = 'Ù‡ÛŒÚ† Ù…ÙˆØ±Ø¯ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ù†Ø´Ø¯Ù‡.'; return }
        for(const it of items){
          const el = document.createElement('div');
          el.className = 'upload-item';
          const title = document.createElement('h4'); title.textContent = it.title;
          const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = `${new Date(it.createdAt).toLocaleString()} ${it.originalName?('- '+it.originalName):''}`;
          el.appendChild(title);
          el.appendChild(meta);
          if(it.textContent){ const p = document.createElement('p'); p.textContent = it.textContent; el.appendChild(p); }
          const controlsWr = document.createElement('div'); controlsWr.style.marginTop = '8px';
          if(it.file){
            const playBtn = document.createElement('button');
            playBtn.className = 'play-pill small';
            playBtn.innerHTML = `<span class="icon">â–¶</span><span class="label">Play</span>`;
            playBtn.addEventListener('click', (e)=>{
              e.stopPropagation();
              // compare current audio src by pathname to avoid mismatches between
              // absolute URLs (audio.src) and stored relative paths (it.file)
              let playingSame = false;
              try{
                const curPath = audio.src ? new URL(audio.src, location.origin).pathname : '';
                playingSame = (curPath === it.file);
              }catch(e){
                playingSame = (audio.src === it.file);
              }
              if(playingSame && !audio.paused){
                audio.pause();
                document.querySelectorAll('.play-pill').forEach(p=>setButtonPlaying(p, false));
                const ic = apPlay && apPlay.querySelector('.icon'); if(ic) ic.textContent = 'â–¶';
              } else setPlayingSource(it.file, playBtn);
            });
            controlsWr.appendChild(playBtn);
            const a = document.createElement('a'); a.href = it.file; a.target = '_blank'; a.textContent = 'Ø¯Ø§Ù†Ù„ÙˆØ¯/Ù…Ø´Ø§Ù‡Ø¯Ù‡ ÙØ§ÛŒÙ„';
            controlsWr.appendChild(a);
          } else if(it.textContent){
            const view = document.createElement('a'); view.href = `/episode.html?id=${it.id}`; view.textContent = 'Ù…Ø´Ø§Ù‡Ø¯Ù‡Ù” Ø¬Ø²Ø¦ÛŒØ§Øª'; controlsWr.appendChild(view);
          }
          // upload cover control for list view
          // note: upload controls removed from home page (use admin page to upload/replace files)
          el.appendChild(controlsWr);
          uploadsList.appendChild(el);
        }
      }

      function renderEpisodeGrid(items){
        episodeGrid.innerHTML = '';
        if(!items || items.length===0) { episodeGrid.textContent = 'Ù‡ÛŒÚ† Ø§Ù¾ÛŒØ²ÙˆØ¯ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª.'; return }
        for(const it of items){
          const card = document.createElement('article'); card.className = 'card';
          const thumb = document.createElement('div'); thumb.className = 'thumb';
          const coverUrl = it.cover || (it.file && it.mime && it.mime.startsWith('image/') ? it.file : '/placeholder.svg');
          thumb.style.backgroundImage = `url('${coverUrl}')`;
          card.appendChild(thumb);
          const h3 = document.createElement('h3');
          // show the admin `title` if present, otherwise fallback to `description`
          h3.textContent = it.title || it.description || 'Ø§Ù¾ÛŒØ²ÙˆØ¯';
          card.appendChild(h3);
          if(it.description){ const descEl = document.createElement('p'); descEl.className = 'card-desc'; descEl.textContent = it.description; card.appendChild(descEl); }
          const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = it.mime || '';
          card.appendChild(meta);
          const controls = document.createElement('div'); controls.style.marginTop='8px';
          const playBtn = document.createElement('button'); playBtn.className='play-pill small'; playBtn.innerHTML = `<span class="icon">â–¶</span><span class="label">Play</span>`;
          playBtn.addEventListener('click', (e)=>{
            e.stopPropagation();
            let playingSame = false;
            try{
              const curPath = audio.src ? new URL(audio.src, location.origin).pathname : '';
              playingSame = (curPath === it.file);
            }catch(e){
              playingSame = (audio.src === it.file);
            }
            if(playingSame && !audio.paused){
              audio.pause();
              document.querySelectorAll('.play-pill').forEach(p=>setButtonPlaying(p, false));
                const ic = apPlay && apPlay.querySelector('.icon'); if(ic) ic.textContent = 'â–¶';
            } else setPlayingSource(it.file, playBtn);
          });
          controls.appendChild(playBtn);
          // upload controls removed on index page; use admin UI for uploads
          card.appendChild(controls);
          // clicking the whole card should set this item into the hero and scroll up
          card.addEventListener('click', (e)=>{
            // prevent any default navigation (some browsers or overlays might open links)
            try{ e.preventDefault(); e.stopPropagation(); }catch(err){}
            // mark as user-selected so subsequent poll updates don't immediately override
            try{ heroUserLocked = true; if(heroLockTimer) clearTimeout(heroLockTimer); heroLockTimer = setTimeout(()=>{ heroUserLocked = false; heroLockTimer = null; }, 60_000); }catch(e){}
            setHeroItem(it, { user: true });
            try{ window.scrollTo({ top: 0, behavior: 'smooth' }); }catch(e){ window.scrollTo(0,0); }
          });
          episodeGrid.appendChild(card);
        }
      }

      function populateHero(items){
        if(!items || items.length===0) return;
        // prefer the first item that has an explicit cover; otherwise fallback to the newest item
        const it = items.find(i => i.cover) || items[0];
        setHeroItem(it);
      }

      function setHeroItem(it, opts){
        if(!it) return;
        // if user locked the hero (clicked a card recently), ignore automatic updates
        if(heroUserLocked && !(opts && opts.user)) return;
        // Prefer `title` for the hero heading; fall back to `description` if title missing
        heroTitle.textContent = it.title || it.description || '';
        // keep textContent (longer notes) or description in the summary area
        heroSummary.textContent = it.textContent || it.description || '';
        heroMeta.textContent = it.mime || '';
        // prefer explicit cover; fallback to file if it's an image, otherwise placeholder
        const coverUrl = it.cover || (it.file && it.mime && it.mime.startsWith('image/') ? it.file : '/hero.svg');
        // set image src for reliable object-fit handling; show img and clear CSS background
        if(heroImg){ heroImg.style.display='block'; heroImg.src = coverUrl; }
        // clear any bg fallback and use image area
        try{ heroCover.style.backgroundImage = ''; heroCover.style.backgroundColor = ''; }catch(e){}
        if(it.file && it.mime && it.mime.startsWith('audio')){
          heroPlay.onclick = ()=>{
            let playingSame = false;
            try{ const curPath = audio.src ? new URL(audio.src, location.origin).pathname : ''; playingSame = (curPath === it.file); }
            catch(e){ playingSame = (audio.src === it.file); }
            if(playingSame && !audio.paused){
              audio.pause(); document.querySelectorAll('.play-pill').forEach(p=>setButtonPlaying(p, false)); const ic = apPlay && apPlay.querySelector('.icon'); if(ic) ic.textContent = 'â–¶';
              return;
            }
            setPlayingSource(it.file, heroPlay);
          };
        } else {
          if(heroPlay) heroPlay.onclick = null;
        }
      }

      function renderStats(items){
        statEpisodes.textContent = (items.length||0) + ' Ø§Ù¾ÛŒØ²ÙˆØ¯';
        // listeners placeholder
        statListeners.textContent = '0+ Ø´Ù†ÙˆÙ†Ø¯Ù‡';
      }

      function renderCategories(items){
        const cats = new Set();
        items.forEach(it => { if(it.description) { const m = it.description.split('â€¢'); if(m[1]) cats.add(m[1].trim()); } });
        categoryChips.innerHTML='';
        const all = document.createElement('button'); all.className='tab active'; all.textContent='Ù‡Ù…Ù‡';
        all.addEventListener('click', ()=>{
          // set active state
          categoryChips.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
          all.classList.add('active');
          renderEpisodeGrid(allUploads);
        });
        categoryChips.appendChild(all);
        cats.forEach(c=>{
          const b = document.createElement('button'); b.className='tab'; b.textContent=c;
          b.addEventListener('click', ()=>{
            categoryChips.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
            b.classList.add('active');
            renderEpisodeGrid(allUploads.filter(it=> (it.description||'').includes(c)));
          });
          categoryChips.appendChild(b);
        });
      }

      // load existing uploads on page load
      fetchUploads();
      // poll for updates so admin edits appear on the public page without manual refresh
      setInterval(fetchUploads, 8000);
      // Listen for cross-tab notifications from admin to refresh immediately
      window.addEventListener('storage', (e) => {
        try{
          if(e.key === 'kj_updates') fetchUploads();
        }catch(err){}
      });

      // Search binding: realtime filter by title or originalName
      const searchEl = document.getElementById('siteSearch');
      if(searchEl){
        let last = '';
        searchEl.addEventListener('input', (e)=>{
          const q = (e.target.value||'').trim().toLowerCase();
          if(q === last) return; last = q;
          if(!q) return renderEpisodeGrid(allUploads);
          const filtered = allUploads.filter(it => (it.title||'').toLowerCase().includes(q) || (it.originalName||'').toLowerCase().includes(q) || (it.description||'').toLowerCase().includes(q));
          renderEpisodeGrid(filtered);
        });
      }

      // --- Search modal behavior ---
      const siteSearch = document.getElementById('siteSearch');
      const searchModal = document.getElementById('searchModal');
      const searchInputModal = document.getElementById('searchInputModal');
      const searchResults = document.getElementById('searchResults');
      const searchClose = document.getElementById('searchClose');

      function openSearch(query){
        if(!searchModal) return;
        searchModal.style.display = 'flex';
        if(searchInputModal){ searchInputModal.value = query||''; searchInputModal.focus(); }
        performSearch(query||'');
      }
      function closeSearch(){ if(searchModal){ searchModal.style.display='none'; } if(searchResults) searchResults.innerHTML=''; }

      async function performSearch(q){
        try{
          const res = await fetch('/api/uploads');
          if(!res.ok) return;
          const items = await res.json();
          const out = items.filter(it=> (it.title||'').toLowerCase().includes(q.toLowerCase()) || (it.description||'').toLowerCase().includes(q.toLowerCase()) || (it.originalName||'').toLowerCase().includes(q.toLowerCase()));
          if(!searchResults) return;
          searchResults.innerHTML = '';
          if(out.length===0) searchResults.textContent = 'Ù†ØªÛŒØ¬Ù‡â€ŒØ§ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯.';
          for(const it of out){
            const el = document.createElement('div'); el.className='item'; el.textContent = (it.title||it.originalName||'Ø§Ù¾ÛŒØ²ÙˆØ¯');
            el.addEventListener('click', ()=>{ closeSearch(); setHeroItem(it); setPlayingSource(it.file, null); });
            searchResults.appendChild(el);
          }
        }catch(e){ console.error(e); }
      }

      if(siteSearch){ siteSearch.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ openSearch(siteSearch.value); } }); }
      if(searchClose) searchClose.addEventListener('click', closeSearch);
      if(searchInputModal) searchInputModal.addEventListener('input', (e)=>performSearch(e.target.value));

      // --- Keyboard shortcuts ---
      // `/` opens search when not typing; `Ctrl+K` and `Alt+/` are alternatives; `Esc` closes.
      document.addEventListener('keydown', (e) => {
        try{
          const active = document.activeElement;
          const isTyping = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable);
          // Ctrl+K or Cmd+K
          if ((e.ctrlKey || e.metaKey) && e.key && e.key.toLowerCase() === 'k') {
            e.preventDefault();
            openSearch('');
            return;
          }
          // Alt+/ (alternative for browsers that capture plain '/')
          if (e.altKey && e.key === '/') {
            e.preventDefault();
            openSearch('');
            return;
          }
          // plain / when not typing (no modifiers)
          if (!e.metaKey && !e.ctrlKey && !e.altKey && e.key === '/' && !isTyping) {
            e.preventDefault();
            openSearch('');
            return;
          }
          if (e.key === 'Escape') {
            closeSearch();
            if(active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')) active.blur();
          }
        }catch(err){}
      });

      // Global audio persistence: save current play src and time
      function saveAudioState(){
        try{
          const state = { src: audio.src||null, time: Math.floor(audio.currentTime||0), paused: audio.paused };
          localStorage.setItem('kj_audio', JSON.stringify(state));
        }catch(e){ }
      }

      function restoreAudioState(){
        try{
          const s = localStorage.getItem('kj_audio'); if(!s) return;
          const st = JSON.parse(s);
          if(st.src){ audio.src = st.src; audio.currentTime = st.time||0; if(!st.paused){ audio.play().then(()=>{ updateApIcon(true); }).catch(()=>{}); } }
        }catch(e){ }
      }

      // save periodically and on pause/seek
      audio.addEventListener('pause', saveAudioState);
      audio.addEventListener('play', saveAudioState);
      audio.addEventListener('timeupdate', ()=>{ if(!audio.paused && Math.floor(audio.currentTime) % 5 === 0) saveAudioState(); });
      restoreAudioState();
      // keep UI in sync when audio stops/pauses â€” reset icons and re-enable any disabled play buttons
      audio.addEventListener('pause', ()=>{
        document.querySelectorAll('.play-pill').forEach(p=>{
          try{ setButtonPlaying(p, false); p.disabled = false; }catch(e){}
        });
        const ic = apPlay && apPlay.querySelector('.icon'); if(ic) ic.textContent = 'â–¶';
      });
      audio.addEventListener('ended', ()=>{
        document.querySelectorAll('.play-pill').forEach(p=>{
          try{ setButtonPlaying(p, false); p.disabled = false; }catch(e){}
        });
        const ic = apPlay && apPlay.querySelector('.icon'); if(ic) ic.textContent = 'â–¶';
      });
      // apply site theme from localStorage (if set)
      (function(){
        try{
          const t = localStorage.getItem('site-theme') || 'light';
          if(t === 'dark') document.documentElement.classList.add('dark-mode');
          const themeToggle = document.getElementById('themeToggle');
          if(themeToggle){ themeToggle.textContent = document.documentElement.classList.contains('dark-mode') ? 'â˜€ï¸' : 'ğŸŒ™';
            themeToggle.addEventListener('click', ()=>{
              const cur = document.documentElement.classList.contains('dark-mode') ? 'dark' : 'light';
              const next = cur === 'dark' ? 'light' : 'dark';
              if(next === 'dark') document.documentElement.classList.add('dark-mode'); else document.documentElement.classList.remove('dark-mode');
              themeToggle.textContent = next === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
              localStorage.setItem('site-theme', next);
            });
          }
        }catch(e){}
      })();
    </script>

    <!-- Sticky audio player -->
    <div id="stickyPlayer" class="sticky-player" aria-hidden="false" style="display:none">
      <button id="spBack" class="btn" title="Back 15s">âª</button>
      <button id="spPlay" class="btn" title="Play/Pause">â–¶</button>
      <button id="spFwd" class="btn" title="Forward 15s">â©</button>
      <div class="label" id="spLabel">â€”</div>
      <label style="margin-left:auto;color:#ddd">Speed:
        <select id="spSpeed" style="background:transparent;color:inherit;border:0">
          <option>0.8</option>
          <option>1</option>
          <option selected>1.25</option>
          <option>1.5</option>
          <option>2</option>
        </select>
      </label>
    </div>

    <!-- Search modal -->
    <div id="searchModal" class="search-modal" role="dialog" aria-modal="true">
      <div class="panel">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
          <input id="searchInputModal" style="flex:1;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#fff" placeholder="Ø¬Ø³ØªØ¬Ùˆ...">
          <button id="searchClose" class="btn">Close âœ–</button>
        </div>
        <div id="searchResults" class="search-results"></div>
      </div>
    </div>
  </body>
</html>
